= Фабрика очередей сообщений

_Фабрика очередей сообщений_ – расширения Службы, которое предоставляет функцию создания _Очереди групп сообщений_ или _Очереди сообщений_.

Класс расширения _Фабрика очередей сообщений_ должен реализовывать интерфейс: `IQueueFactory`.

[source,csharp]
----
public class QueueFactoryExt : IQueueFactory

----

Описание интерфейса приведено в пункте xref:ObjectTypes.adoc[Типы объектов].

В общем случае класс расширения должен содержать метод `CreateQueue`, предоставляющий экземпляр _Очередь групп сообщений_.

== Очередь сообщений

_Очередь групп сообщений_ – объект, предоставлявший функцию получения _Сообщений_ из _Хранилища сообщений_. _Очередь групп сообщений_ должна уметь подключаться к _Хранилищу сообщений_, получать из него исходные данные _Сообщения_ и формировать по ним объект типа `IMessageGroup`.

_Очередь групп сообщений_, создаваемая _Фабрикой очередей сообщений_, должна реализовывать интерфейс `IMessageGroupQueue`, который определяет:

* методы:
* `TryDequeue` – данный метод должен возвращать следующую необработанную _Группу сообщений_. Сообщения группы должны быть заблокированы от возможности повторной обработки (в т. ч. другими экземплярами РП). Блокировка повторной обработки может быть реализована: удалением записи из хранилища, блокировкой (относится к карточкам Docsvision) или иным способом;
* `TryPeek` – данный метод должен возвращать следующую необработанную _Группу сообщений_ без блокировки. Данный метод используется только для проверки наличия необработанных _Сообщений_, поэтому не должен изменять _Хранилище сообщений_;
* `OnMessageGroupProcessingStart` – данный метод может обрабатывать событие начала обработки _Сообщений_ из _Группы сообщений_; метод вызывает перед созданием _Задач_ по _Сообщениям_ группы;
* `OnMessageGroupProcessingFinish` – данный метод может обрабатывать событие завершения обработки _Сообщений_ из _Группы сообщений_; метод вызывает после выполнения _Задач_, созданных по _Сообщениям_ группы;
* `OnMessageProcessingStart` – _зарезервировано_;
* `OnMessageProcessingFinish` – данный метод может обрабатывать событие завершения обработки _Сообщения_ из _Группы сообщений_; метод вызывает после выполнения _Задачи_, созданной по _Сообщению_ группы;
* поле `Id` – должен возвращать уникальный идентификатор данной _Очередь сообщений_;

*Важно. Реализация метода TryDequeue должна гарантировать защиту от повторной обработки Сообщения, загруженного Очередью сообщений*.

Для полной реализации _Очередь сообщений_ нужно разработать три класса:

* _Очереди сообщений_,
* _Группы сообщений_,
* _Сообщения_.

Следующий код демонстрирует пример _Очереди групп сообщений_, получающей _Сообщения_ из файлов на диске.

. Класс _Сообщения_.

```csharp
 public class FSMessage : IMessage
 {
 public Guid Id =&gt; Guid.NewGuid();
 public Guid TypeId =&gt; Constants.FSMessageTypeID;
 public Guid SubTypeId =&gt; Constants.FSMessageSubTypeID;
 public Guid TargetId { get; private set; }
 public Guid SourceId { get; private set; }
 public object Data { get; private set; }
 public string FileName { get; private set; }

----
   // file - файл сообщения
   // sourceId - будем передавать идентификатор Очереди сообщений
   public FSMessage(string file, Guid sourceId)
   {
       SourceId = SourceId;
       FileName = file;

       try
       {
           // В данные сообщения сохраняем содержимое файла
           Data = File.ReadAllText(file);
       }
       catch
       {
           Data = $"Данные файл {file} не прочитаны";
       }
   }
----

}
 ```

. Класс _Группы сообщений_.

```csharp
 public class FSMessageGroup : IMessageGroup
 {
 public Guid Id =&gt; Guid.NewGuid();
 public Guid SourceId { get; private set; }
 public IEnumerable<IMessage> Messages { get; private set; }

----
   // sourceId - будем передавать идентификатор Очереди сообщений
   public FSMessageGroup(Guid sourceId, IEnumerable<IMessage> messages)
   {
       SourceId = sourceId;
       Messages = messages;
   }
----

}
 ```

. Класс _Очереди сообщений_.

```csharp
 public class FSQueue : IMessageGroupQueue
 {
 private readonly string messagesFolder;
 private readonly string processedMessagesFolder;
 private readonly int maxCountMessagesInGroup = 10;

----
   public Guid Id => Constants.FSMessageGroupQueueId;

   public FSQueue(string baseFolder)
   {
       messagesFolder = baseFolder;
       processedMessagesFolder = Path.Combine(baseFolder, "ProcessedMessages");
   }

   public bool TryDequeue(out IMessageGroup result)
   {
       IEnumerable<string> msgFiles = GetMessages();
       result = CreateMessageGroup(msgFiles, Id);

       return result.Messages.Any();
   }

   public bool TryPeek(out IMessageGroup result)
   {
       IEnumerable<string> msgFiles = GetMessagesWithoutLock();
       result = CreateMessageGroup(msgFiles, Id);

       return result.Messages.Any();
   }

   public void OnMessageGroupProcessingFinish(IMessageGroup message)
   {
   }
   public void OnMessageGroupProcessingStart(IMessageGroup message)
   {
   }
   public void OnMessageProcessingFinish(IMessage message, MessageState state, object details)
   {
   }
   public void OnMessageProcessingStart(IMessage message)
   {
   }

   private IEnumerable<string> GetMessages()
   {
       List<string> files = new List<string>();
       FileInfo[] fileInfos = new DirectoryInfo(messagesFolder).GetFiles();

       foreach (FileInfo file in fileInfos)
       {
           if (file == null || files.Count >= maxCountMessagesInGroup)
           {
               break;
           }

           string newFilePath = Path.Combine(processedMessagesFolder, file.Name);
           try
           {
               file.MoveTo(newFilePath);
               files.Add(newFilePath);
           }
           catch { }
       }

       return files;
   }

   private IEnumerable<string> GetMessagesWithoutLock()
   {
       IEnumerable<FileInfo> fileInfos = new DirectoryInfo(messagesFolder).GetFiles().Take(10);

       return fileInfos.Select(t => t.FullName);
   }

   private IMessageGroup CreateMessageGroup(IEnumerable<string> files, Guid sourceId)
   {
       IEnumerable<FSMessage> messages = files.Select(t => new FSMessage(t, sourceId));
       FSMessageGroup messageGroup = new FSMessageGroup(messages, sourceId);

       return messageGroup;
   }
----

}
 ```

Пояснения:

* Внешняя система создаёт файлы с содержимым _Сообщения_ в папке `messagesFolder`.
* Для блокирующей функции `TryDequeue` файлы для обработки предоставляются методом `GetMessages`, который выбирает до 10 сообщений (`maxCountMessagesInGroup`) из папки `messagesFolder`, и для исключения их возможной повторной обработки перемещает обработанные файлы в подпапку `processedMessagesFolder`.
* Из предоставленных методом `GetMessages` файлов формируется _Группа сообщений_ – используется функция `CreateMessageGroup`.
* Для неблокирующей функции `TryPeek` последовательность обработки аналогична, но файлы не перемещаются.

== Пример реализации Фабрики очередей сообщений

Следующий код демонстрирует пример _Фабрики очередей сообщений_, предоставляющей _Очередь групп сообщений_ приведенного выше типа `FSQueue`.

[source,csharp]
----
public class FSQueueFactory : IQueueFactory
{
    public object CreateQueue(string settings)
    {
        FSQueue messageGroupQueue = new FSQueue(settings);
        return messageGroupQueue;
    }
}
----

Метод `CreateQueue` принимает настройки _Фабрики очередей сообщений_ из конфигурации Службы (см. далее). В данном примере в `settings` будет передаваться путь к папке с сообщениями.

== Подключение расширения к Службе

Все следующие действия выполняются на сервере Службы.

. xref:ExtensionRegistration.adoc[Зарегистрируйте разработанное расширения на сервере Службы].

. Добавьте расширение `FSQueueFactory` в конфигурацию Службы:

. Создайте раздел `HKLM\SOFTWARE\DocsVision\WorkerService\5.5\Queues\FSQueue` («FSQueue» – выбрано произвольно) в реестре ОС.

. В созданном разделе:

.. Укажите полное имя класса `FSQueueFactory` в параметре по умолчанию.

. Создайте строковый параметр «FSQueueSettings» (выбрано произвольно) со значением «C:\Messages\» – строка настроек, которая будет передаваться в `IQueueFactory.CreateQueue`.

image:img/queueRegistry.png[]

. Создайте `Роль рабочего процесса`, через которую РП будет получать расширение `FSQueueFactory`:

. Создайте раздел `HKLM\SOFTWARE\DocsVision\WorkerService\5.5\Roles\RoleWithFSQueue` («RoleWithFSQueue» – выбрано произвольно) в реестре ОС.

. В созданном разделе создайте строковый параметр «Queues» со значением «FSQueueSettings» – название строки с параметрами `FSQueueFactory`, которая была создана на шаге 2.2.2.

image:img/queueRoleRegistry.png[]

. Зарегистрируйте экземпляр РП с _Ролью_ «RoleWithFSQueue».

. Создайте раздел `HKLM\SOFTWARE\DocsVision\WorkerService\5.5\Roles\SOFTWARE\DocsVision\WorkerService\5.5\WorkerProcesses\WpFSQueue` («WpFSQueue» – выбрано произвольно) в реестре ОС.

. В созданном разделе создайте параметры:
** «Architecture» с типом DWORD и значением «1» (архитектура – x86);
** «Disabled» с типом DWORD и значением «0»;
** «Roles» со строковым типом и значением «RoleWithFSQueue».

image:img/queueWpRegistry.png[]

== Проверка примера

. Создайте на компьютере папки:
* `C:\Messages`;
* `C:\Messages\ProcessedMessages`;
. Перезапустите службу «WorkerService».

. Создайте в папке `C:\Messages` тестовый файл с произвольным содержимым. 

В течении некоторого времени файл будет перемещен в папку `C:\Messages\ProcessedMessages`.

В данном случае никакая _Задача_ не создаётся – только обрабатывается _Сообщение_. Для того, чтобы по _Сообщению_ создавалась _Задача_ нужно реализовать расширение xref:WorkerTaskFactory.adoc[Фабрика задач], у которой в списке поддерживаемых типов _Сообщений_ (`IWorkerTaskFactory.MessageTypes`) должен быть идентификатор типа _Сообщения_ `FSMessage` (`IMessage.TypeId`).