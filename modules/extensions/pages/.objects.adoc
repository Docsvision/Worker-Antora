= Объекты API

== Задача

_Задача_ является единицей работы модуля. Выполнение _Задач_ является основным назначением Службы {ws}.

_Задачи_ формируются _Фабрикой задач_ (`IWorkerTaskFactory`) из _Сообщений_ (`IMessage`), поступающих от внешних систем. _Задачи_ также могут быть сформированы напрямую в коде.

_Задача_ описывается программным интерфейсом `{dv}.WorkerService.Interfaces.IWorkerTask`.

.Интерфейс определяет единственный метод:
[%collapsible]
====
* `Work()` -- содержит программный код. Исполнение кода является условием для выполнения _Задачи_. Данный метод вызывается _менеджером задач_ (`TaskManager`, внутренний модуль Службы {ws}) для выполнения соответствующей _Задачи_.
====

== Сообщение

_Сообщение_ является единицей информации, по которой в модуле формируется _Задача_.

_Сообщения_ создаются внешней по отношению к модулю системой. Программист сам определяет способ хранения сообщений, их добавления и получения из хранилища. В роли хранилища могут выступать:

- Таблица в БД,
- Карточки в системе {dv},
- Файлы на диске,
- Иные средства.

_Сообщение_ описывается программным интерфейсом `{dv}.WorkerService.Interfaces.IMessage`.

.Интерфейс определяет следующие свойства:
[%collapsible]
====
* `Id` -- должен возвращать уникальный идентификатор _Сообщения_.
* `TypeId` -- должен возвращать идентификатор типа _Сообщения_. Тип _Сообщения_ используется для получения необходимой _Фабрики задач_.
* `SubTypeId` -- должен возвращать идентификатор подтипа _Сообщения_. Подтип _Сообщения_ может использоваться в _Фабрике задач_ для принятия решения о варианте создания _Задачи_ по _Сообщению_.
* `TargetId` -- должен возвращать идентификатор цели события. Может использоваться при создании _Задачи_. `TargetId` может, например, содержать идентификатор карточки, с которой выполняется работа в _Задаче_.
* `SourceId` -- должен возвращать идентификатор источника _Сообщение_. В обычном случае можно возвращать идентификатор _Очереди сообщений_ (`IMessageGroupQueue.Id`). Идентификатор используется при протоколировании ошибок, возникающих при обработке _Сообщений_.
* `Data` -- должен возвращать содержимое сообщение. Содержимое сообщение -- любой объект, который потребуется для создания _Задачи_.
====

== Группа сообщений

Поступившие _Сообщения_ загружаются в обработчик модуля _Группой сообщений_. _Сообщения_ одной группы разбираются последовательно в одном потоке. Разные _Группы сообщений_ обрабатываются в параллельных потоках, если свободные потоки доступны.

_Группа сообщений_ описывается программным интерфейсом `{dv}.WorkerService.Interfaces.IMessageGroup`.

.Интерфейс определяет следующие свойства и методы:
[%collapsible]
====
* `Id` -- должен возвращать уникальный идентификатор _Группы сообщений_.
* `SourceId` -- должен возвращать идентификатор источника _Групп сообщений_. В обычном случае можно возвращать идентификатор _Очереди сообщений_ (`IMessageGroupQueue.Id`). Идентификатор используется для протоколирования ошибок, возникающих во время обработки _Сообщений_.
* `Messages` -- должен возвращать _Сообщения_ данной _Группы сообщений_.
====

== Очередь групп сообщений

_Очередь групп сообщений_ предоставляет доступ к необработанным _Группам сообщений_.

_Очередь групп сообщений_ описывается программным интерфейсом `{dv}.WorkerService.Interfaces.IMessageGroupQueue`.

.Интерфейс определяет следующие методы:
[%collapsible]
====
* `TryDequeue(out IMessageGroup)` -- должен сохранить в `result` следующую _Группу сообщений_ с необработанными _Сообщениями_.
+
Метод должен вернуть `*TRUE*`, если _Группа сообщений_ содержит сообщения, иначе -- `*FALSE*`. Метод должен защитить _Сообщение_, добавляемое в _Группу сообщений_, от возможности добавления в другую _Группу сообщений_ и при формировании группы добавлять только сообщения, которые не были добавлены в другую группу. Это реализуется, например, через установку блокировки или флага обработки.
+
NOTE: _Группы сообщений_ могут обрабатываться параллельно, поэтому программисту важно организовать функцию `TryDequeue` (или способ получения _Сообщений_ из хранилища) таким образом, чтобы *исключить возможность повторной обработки* _Сообщений_.
+
* `TryPeek(out IMessageGroup)` -- аналогично `TryDequeue`, но без блокировки _Сообщений_. Данный метод предназначен для проверки наличия необработанных _Сообщений_.
+
* Унаследованные методы интерфейса `IMessageGroupSource`.
====

== Фабрика очередей сообщений

_Фабрика очередей сообщений_ предоставляет методы получения _Очередей сообщений_.

_Фабрика очередей сообщений_ является одной из точек расширения Службы {ws}. Данное расширение обеспечивает возможность получения _Сообщений_ через _Очередь групп сообщений_ из хранилища, выбранного программистом.

[#IQueueFactory]
_Фабрика очередей сообщений_ описывается программным интерфейсом `{dv}.WorkerService.Interfaces.IQueueFactory`.

.Интерфейс определяет единственный метод:
[%collapsible]
====
* `CreateQueue(String)` -- должен вернуть _Очередь групп сообщений_ (`IMessageGroupQueue`).
+
Данный метод вызывается при запуске _{of-ws}_ Службы. В `settings` передаётся строка настроек, установленная для данной очереди в конфигурации, переданной _фоновой операции_. Если конфигурация содержит несколько настроек, метод `CreateQueue` будет вызван для каждой.
+
Класс, реализующий `IQueueFactory` также может реализовывать `IInitializeWithServiceProvider` для получения _поставщика сервисов_.
====

== Фабрика задач

_Фабрика задач_ предоставляет методы формирования _Задач_ по _Сообщениям_ .

_Фабрика задач_ является одной из точек расширения Службы {ws}. Данное расширение обеспечивает возможность формирования _Задач_ с типом, который реализован программистом.

[#IWorkerTaskFactory]
_Фабрика задач_ описывается программным интерфейсом `{dv}.WorkerService.Interfaces.IWorkerTaskFactory`

.Интерфейс определяет следующие методы и свойства:
[%collapsible]
====
* `Id` -- должен возвращать уникальный идентификатор _Фабрики задач_.
+
* `MessageTypes` -- должен возвращать идентификаторы поддерживаемых типов _Сообщений_.
+
При обработке _Сообщения_ для создания _Задачи_ выбирается _Фабрика задач_, `MessageTypes` которой содержит идентификатор типа сообщения `IMessage.TypeId`.
+
* `CreateWorkerTask(IMessage)` -- должен создавать _Задачу_ по переданному _Сообщению_.
+
* `CreateWorkerTask(IMessage, IWorkerTask)` -- должен создавать _Задачу_ по переданному _Сообщению_. В `previousTask` будет передана последняя обработанная _Задача_.
====

== Фабрика подключений

_Фабрика подключений_ предоставляет подключение к внешнему ресурсу. Подключение может использоваться при получении _Сообщений_, при выполнении _Задач_, в работе _Компонентов_.

_Фабрика подключений_ является одной из точек расширения Службы {ws}. Данное расширение обеспечивает стандартный способ получения подключения к внешнему ресурсу, разработанный программистом.

[#IConnectionFactory]
_Фабрика подключений_ описывается программным интерфейсом `{dv}.WorkerService.Interfaces.IConnectionFactory`.

.Интерфейс определяет следующие методы и свойства:
[%collapsible]
====
* `CreateConnection<T>(String)` -- должен создавать и возвращать подключение с типом `T`. В `settings` передаётся строка подключения из конфигурации данного подключения.
* `SupportedTypes` -- должен возвращать типы подключений, которые могут быть созданы методом `CreateConnection`.
====

== Компонент

_Компонент_ -- реализуемый программистом дополнительный модуль Службы {ws}, который может содержать любую функциональность. _Компонент_ является одной из точек расширения Службы, он не связан с циклом обработки _Сообщений_ и _Задач_ и предоставляет программисту возможность реализовать любую функциональность и получать xref:.services.adoc[сервисы API].

Служба может выполнять работы не только с помощью сообщений, но и с помощью _Компонентов_. Компоненты инициализируются при запуске _{of-ws}_ и останавливаются при его остановке.

[#IThreadedRuntimeComponent]
_Фабрика подключений_ описывается программным интерфейсом `{dv}.WorkerService.Interfaces.IThreadedRuntimeComponent`.

.Интерфейс определяет следующие методы и свойства:
[%collapsible]
====
* `Start()` -- должен запускать выполняемые функции _Компонента_. Данный метод будет вызван один раз при запуске _{of-ws}_.
* `Stop()` -- должен останавливать выполняемые функции _Компонента_. Данный метод будет вызван по завершении работы _{of-ws}_.
* `Stopped` -- должен вернуть текущее состояние работы _Компонента_: `*false*` -- остановлен, `*true*` -- запущен.
====

При реализации `Компонента` с наследованием от `IThreadedRuntimeComponent` необходимо проверить, поступил ли сигнал `IProcessShutdownNotificator.Signal`, означающий завершение работы {of-ws}. При этом работа компонента также должна быть завершена.

Рекомендуется в компонентах реализовать интерфейс `IThreadedRuntimeComponent` или установить наследование от класса `ThreadedRuntimeComponent`.

== IMessageGroupSource

Интерфейс `{dv}.WorkerService.Interfaces.IMessageGroupSource` определяет методы обработки _Групп сообщений_.

.Интерфейс определяет следующие методы:
[%collapsible]
====
* `OnMessageGroupProcessingStart(IMessageGroup)` -- должен обрабатывать запуск обработки _Группы сообщений_. Метод вызывается при отправке _Группы сообщений_ на обработку.
* `OnMessageGroupProcessingFinish(IMessageGroup)` -- должен обрабатывать завершение обработки _Группы сообщений_. Метод вызывается после обработки всех сообщений _Группы сообщений_.
* Унаследованные методы интерфейса `IMessageSource`.
====

== IMessageQueue

Интерфейс `{dv}.WorkerService.Interfaces.IMessageQueue` определяет методы получения _Сообщений_ из _Очереди сообщений_.

.Интерфейс определяет следующие методы:
[%collapsible]
====
* `TryDequeue(out IMessage)` -- должен сохранить в `result` следующее необработанное _Сообщение_ из _Очереди сообщений_. Если есть необработанная _Группа сообщений_ метод должен вернуть `*TRUE*`, иначе `*FALSE*`.
+
_Метод зарезервирован (не используется)_.
+
* `TryPeek(out IMessage)` -- должен сохранить в `result` следующее необработанное _Сообщение_ из _Очереди сообщений_. Если есть необработанная _Группа сообщений_ метод должен вернуть `*TRUE*`, иначе `*FALSE*`.
+
_Метод зарезервирован (не используется)_.
+
* Унаследованные методы интерфейса `IMessageSource`.
====

== IMessageSource

Интерфейс `{dv}.WorkerService.Interfaces.IMessageSource` определяет методы обработки _Сообщений_.

.Интерфейс определяет следующие методы и свойства:
[%collapsible]
====
* `Id` -- должен возвращать уникальный идентификатор данного источника сообщений.
* `OnMessageProcessingStart(IMessage)` -- должен обрабатывать запуск обработки _Сообщения_.
+
_Метод зарезервирован (не используется)_.
+
* `OnMessageProcessingFinish(IMessage, MessageState, Object)` -- должен обрабатывать завершениt обработки _Сообщения_.
+
Метод вызывается после выполнения _Задания_, созданного по _Сообщению_ `message`. В `state` передаётся статус, с которым было обработано сообщение. В `details` передаётся содержание ошибки.
====

== IWorkerProcessManager

Интерфейс `{dv}.WorkerService.Interfaces.IWorkerProcessManager` определяет методы _Менеджера процессов_.

.Интерфейс определяет следующие методы, события и свойства:
[%collapsible]
====
* `Processes` -- возвращает информацию о фоновых операциях.
* `StartProcess(String)` -- запускает фоновую операцию с указанным именем.
* `StopProcess(String, Boolean)` -- останавливает фоновую операцию с указанным именем.
+
_Метод зарезервирован (не используется)_.
+
* `StartProcesses()` -- запускает все фоновые операции.
* `StopProcesses(Boolean)` -- останавливает все фоновые операции.
* `ProcessStarted` -- запуск {of-ws}.
* `ProcessStopped` -- остановка {of-ws}.
====

== ISettings

Интерфейс `{dv}.WorkerService.Interfaces.IThreadedRuntimeComponent` определяет методы получения настроек _Компонента_.

.Интерфейс определяет единственное свойство:
[%collapsible]
====
* `Data` -- получает или возвращает строку настроек _Компонента_. Настройки сохраняются в `Data` перед вызовом метода `IThreadedRuntimeComponent.Start` класса _Компонента_.
====

== IInitializeWithServiceProvider

Интерфейс `{dv}.WorkerService.Interfaces.IInitializeWithServiceProvider` определяет метод получения Поставщика сервисов.

.Интерфейс определяет единственный метод:
[%collapsible]
====
* `Initialize(IServiceProvider)` -- принимает поставщика сервисов.
====
